\subsection{Discrete Event Simulation}
% TODO: Write DES subsection - emphasise on custom Node + include some code for
% node class
This section describes the discrete event simulation (DES) model used to
represent the queueing network.
The python library \lstinline[style=pystyle]{ciw}~\cite{ciwpython, ciwarticle}
was used to implement the DES model.
The library treats queues as distinct nodes in the network where each node has
an arrival distribution, a service distribution, a number of available servers
and a queue capacity.
For more complex systems additional inputs can be used (baulking, reneging,
priority change) but for the model described in this section these won't be
needed.
The following code can be used to generate a queueing network with two
queues and two types of individuals, where type 1 individuals arrive at node
2 (waiting zone 1) with an arrival rate of \lstinline[style=pystyle]{lambda_1}
and type 2 individuals arrive at node 1 (waiting zone 2) with an arrival rate of
\lstinline[style=pystyle]{lambda_2}.
Node 1 has a deterministic fixed service rate of \lstinline[style=pystyle]{0}
(since there is no service involved in the buffer centre) and node 2 has an
exponential service rate of \lstinline[style=pystyle]{mu}.

\begin{lstlisting}[style=pystyle]
>>> import ciw
>>> model = ciw.create_network(
...     arrival_distributions=[
...         ciw.dists.Exponential(lambda_2),
...         ciw.dists.Exponential(lambda_1)
...     ],
...     service_distributions=[
...         ciw.dists.Deterministic(0), ciw.dists.Exponential(mu)
...     ],
...     routing=[
...         [0.0, 1.0],
...         [0.0, 0.0]
...     ],
...     number_of_servers=[buffer_capacity, num_of_servers],
...     queue_capacities=[0, system_capacity - num_of_servers],
... )
\end{lstlisting}

As described earlier in section \ref{sec:queueing-section} and as shown in
figure \ref{fig:diagram_of_queueing_system}, type 1 individuals arrive at node 2
and exit the system after their service finishes, but type 2 individuals arrive
at node 1 and then proceed to node 2 after leaving node 1.
This logic is implemented in the queueing network using the
\lstinline[style=pystyle]{routing} matrix that consists of the routing
probabilities between different nodes.
For the current implementation the routing matrix is a \(2 \times 2\) array
that routes individuals from node 1 to node 2 with a probability of \(1.0\).
Furthermore, the server availability for nodes 1 and 2 are set to
the \lstinline[style=pystyle]{buffer_capacity} and
\lstinline[style=pystyle]{num_of_servers} respectively and the queue capacities
are set to \lstinline[style=pystyle]{0} and
\lstinline[style=pystyle]{system_capacity - num_of_servers}.
Note that for node 1 (i.e. waiting zone 2) queue capacity is set to 0 and its
number of servers is set to the buffer capacity.
From \lstinline[style=pystyle]{ciw}'s data records perspective this made more
sense since individuals are recorded as blocked this way.
If the queue capacity was non-zero, individuals could also have a waiting time
but no waiting should take place in node 1, only blockage.


\subsubsection{Custom node class}
Another specific feature of the particular model is that type 2 individuals
need to stay blocked in node 2 whenever the number of individuals in node 1
reaches a certain threshold \(T\).
This part of the queueing network is not as straightforward to implement as the
rest of the model.
\lstinline[style=pystyle]{Ciw} allows users to get more custom behaviour by
creating their own node class that inherits from the original one.
By inheriting the original \lstinline[style=pystyle]{ciw.Node} the general
behaviour of all nodes can be altered.


\begin{lstlisting}[style=pystyle]

>>> def build_custom_node(threshold=float("inf")):
...     """
...     Build a custom node to replace the default ciw.Node. Inherits from
...     the original ciw.Node class and replaces methods
...     release_blocked_individual and finish_service.
...     The methods are modified in such a way that all individuals that
...     are in the buffer space (node 1) stay blocked as long as the
...     number of individuals in the service area node (node 2) exceeds the
...     threshold.
...
...     Parameters
...     ----------
...     threshold : int, optional
...         The capacity threshold to be used by the method
...     Returns
...     -------
...     class
...         A custom node class that inherits from ciw.Node
...     """
...
...     class CustomNode(ciw.Node):
...         """
...         Overrides the default release_blocked_individual and
...         finish_service methods of the ciw.Node class
...         """
...
...         def __init__(self, id_, simulation):
...             """
...             Initializes the node with the given id and simulation using
...             the initialisation of ciw's Node object with the addition of
...             the threshold parameter.
...             """
...             super().__init__(id_, simulation)
...             self.simulation.threshold = threshold
...
...         def release_blocked_individual(self):
...             """
...             Releases an individual who becomes unblocked when
...             another individual is released:
...             - check if individual in node 2 and should stay blocked
...                 i.e. if the number of individuals in that
...                      node > threshold
...             - check if anyone is blocked by this node
...             - find the individual who has been blocked the longest
...             - remove that individual from blocked queue
...             - check if that individual had their service interrupted
...             - release that individual from their node
...             """
...             continue_blockage = (
...                 self.number_of_individuals >= threshold
...                 and self.id_number == 2
...             )
...             if (
...                 self.len_blocked_queue > 0
...                 and self.number_of_individuals < self.node_capacity
...                 and not continue_blockage
...             ):
...                 receiving_node = (
...                     self.simulation.nodes[self.blocked_queue[0][0]]
...                 )
...                 individual_to_receive_index = [
...                     ind.id_number
...                     for ind in receiving_node.all_individuals
...                 ].index(self.blocked_queue[0][1])
...                 individual_to_receive = (
...                     receiving_node.all_individuals[
...                         individual_to_receive_index
...                     ]
...                 )
...                 self.blocked_queue.pop(0)
...                 self.len_blocked_queue -= 1
...                 if individual_to_receive.interrupted:
...                     individual_to_receive.interrupted = False
...                     receiving_node.interrupted_individuals.remove(
...                         individual_to_receive
...                     )
...                     receiving_node.number_interrupted_individuals -= 1
...                 receiving_node.release(individual_to_receive_index, self)
...
...         def finish_service(self):
...             """
...             The next individual finishes service:
...             - finds the individual to finish service
...             - check if they need to change class
...             - find their next node
...             - release the individual if there is capacity at destination,
...                 otherwise cause blockage
...             - Note that blockage also occurs when we are at node 1 and
...                 the number of individuals on node 2 are more than the
...                 'threshold'
...             """
...             (
...                 next_individual,
...                 next_individual_index
...             ) = self.find_next_individual()
...             self.change_customer_class(next_individual)
...             next_node = self.next_node(next_individual)
...             next_individual.destination = next_node.id_number
...             if not np.isinf(self.c):
...                 next_individual.server.next_end_service_date=float("Inf")
...             blockage = (
...                 next_node.number_of_individuals >= threshold
...                 and self.id_number == 1
...             )
...             if (
...                 next_node.number_of_individuals < next_node.node_capacity
...             ) and not blockage:
...                 self.release(next_individual_index, next_node)
...             else:
...                 self.block_individual(next_individual, next_node)
...
...     return CustomNode
\end{lstlisting}
% TODO: Is this too long? Should I only include the "important" stuff?

The class \lstinline[style=pystyle]{CustomNode} inherits from
\lstinline[style=pystyle]{ciw.Node} and changes two of the methods
(\lstinline[style=pystyle]{release_blocked_individual} and
\lstinline[style=pystyle]{finish_service}) so that the additional logic of the
threshold is incorporated.
In the \lstinline[style=pystyle]{release_blocked_individual} method an
additional check is added before releasing a potentially blocked individual from
node 1 to node 2.
This essentially checks whether the id of the node is 2 and
the number of individuals in it are more than or equal to the
\lstinline[style=pystyle]{threshold} so that it can accept a blocked individual.
Similarly \lstinline[style=pystyle]{finish_service} is called once an individual
finishes their service.
The additional check that was added checks whether the id of the node is 1 and
the number of individuals in the next node (i.e. node 2) is more than the
threshold, which would result in blockage.
Finally, the simulation object can be created and simulated for a specific
\lstinline[style=pystyle]{threshold} and \lstinline[style=pystyle]{runtime} by
running:

\begin{lstlisting}[style=pystyle]

>>> custom_node = build_custom_node(threshold)
>>> simulation = ciw.Simulation(model, node_class=custom_node)
>>> simulation.simulate_until_max_time(runtime)

\end{lstlisting}


