\chapter{The \texttt{ambulance\_game} Python library}
\label{appendix:ambulance_game}

This chapter of the appendix provides an overview of the
\texttt{ambulance\_game} Python library.
This is a library that accompanies all chapters of this thesis and provides
the functionality to run the mathematical models and simulations described
in the thesis.
The library uses the best available tools to ensure the code is correct,
readable, well-documented and properly tested.
These tools are outlined in Section~\ref{sec:intro_test_code}.
The library is also publicly available on GitHub and has been archived on
Zenodo~\cite{ambulance_game_github_repo}.

This appendix chapter is structured based on the Diataxis
framework~\cite{Procida_Diataxis_documentation_framework}.
The structure of the chapter is as follows:

\begin{itemize}
    \item Section~\ref{sec:ambulance_game_installation} provides instructions
        on how to install the library.
    \item Section~\ref{sec:ambulance_game_tutorial} a learning-oriented lesson
        on performing a specific task using the library.
    \item Section~\ref{sec:ambulance_game_how_to} provides a goal-oriented
        how-to guide on how to use the library.
    \item Section~\ref{sec:ambulance_game_reference} provides some technical
        descriptions of the library and how to use it.
    \item Section~\ref{sec:ambulance_game_explanation} provides a discussion
        of some of the details of the library.
\end{itemize}


\section{Installation}\label{sec:ambulance_game_installation}

The \texttt{ambulance\_game} library is published on PyPI~\cite{pypi}
and can be installed using the \texttt{pip} package manager:

\definecolor{bashcol}{RGB}{211, 211, 211}
\begin{lstlisting}[
    language=bash,
    basicstyle=\ttfamily\scriptsize,
    backgroundcolor=\color{bashcol},
    frame=shadowbox,
    mathescape=false,
]
$ python -m pip install ambulance_game
\end{lstlisting}

Alternatively, a development version of the library can be installed from
GitHub.
The following commands clone the repository, install the \texttt{flit}
package manager and install the library in development mode: 

\begin{lstlisting}[
    language=bash,
    basicstyle=\ttfamily\scriptsize,
    backgroundcolor=\color{bashcol},
    frame=shadowbox,
    mathescape=false,
]
$ git clone https://github.com/MichalisPanayides/AmbulanceDecisionGame.git
$ cd AmbulanceDecisionGame
$ python -m pip install flit
$ python -m flit install --symlink
\end{lstlisting}

To make sure that the library is installed correctly, and to check that the
tests pass, the following command install the \texttt{tox} package manager
and runs the tests:

\begin{lstlisting}[
    language=bash,
    basicstyle=\ttfamily\scriptsize,
    backgroundcolor=\color{bashcol},
    frame=shadowbox,
    mathescape=false,
]
$ python -m pip install tox
$ python -m tox
\end{lstlisting}


\section{Tutorial}\label{sec:ambulance_game_tutorial}

The following tutorial provides a step-by-step tutorial on how to get the Nash
equilibrium of an instance of the game between two hospitals and an ambulance
service provider using the \texttt{ambulance\_game} library.
Table~\ref{tab:ambulance_game_example} provides the parameters of the game
instance.

\begin{table}[H]
    \begin{center}
        \begin{tabular}{||c|c|c|c||}
            \hline
            \(\lambda_2\) & t & \footnotesize{\(\hat{P}\)} & \(\alpha\) \\
            \hline\hline
            8 & 2 & 0.7 & 0.5 \\
            \hline
        \end{tabular}

        \vspace{0.3cm}

        \begin{tabular}{||c|c|c|c|c|c||}
            \hline
            \(\lambda_1^A\) & \(\mu^A\) & \(C^A\) & \(N^A\) & \(M^A\) \\
            \hline\hline
            1 & 3 & 2 & 10 & 5 \\
            \hline
        \end{tabular}

        \vspace{0.3cm}
        
        \begin{tabular}{||c|c|c|c|c|c||}
            \hline
            \(\lambda_1^B\) & \(\mu^B\) & \(C^B\) & \(N^B\) & \(M^B\) \\
            \hline\hline
            2 & 1 & 3 & 10 & 5 \\
            \hline
        \end{tabular}
    \end{center}
    \label{tab:ambulance_game_example}
    \caption{Parameters of the game}
\end{table}

A full description of the parameters of the game can also be found in
Section~\ref{sec:game_players_and_parameters}.
The code snippet in Listing~\ref{lst:abg_tutorial_parameters} defines the
parameters of the game instance using Python.

\begin{lstlisting}[
    style=pystyle,
    caption={Python code that defnies the parameters.},
    label={lst:abg_tutorial_parameters},
]
>>> lambda_2 = 8
>>> target = 2
>>> alpha = 0.5
>>> p_hat = 0.7
>>>
>>> lambda_1_1 = 1
>>> mu_1 = 3
>>> num_of_servers_1 = 2
>>> system_capacity_1 = 10
>>> buffer_capacity_1 = 5
>>>
>>> lambda_1_2 = 2
>>> mu_2 = 1
>>> num_of_servers_2 = 3
>>> system_capacity_2 = 10
>>> buffer_capacity_2 = 5

\end{lstlisting}

The arrival rate of type 2 individuals (ambulance patients) is set to
\texttt{lambda\_2 = 8}.
The parameters that correspond to the policy imposed to the hospitals are
\texttt{target = 2} and \texttt{p\_hat = 0.7}.
This means that the hospitals should aim to serve \(70\%\) of the patients
that arrive at the hospital within \(2\) time units.

The python code shown in~\ref{lst:abg_tutorial_game_instance} uses the
parameters of the current game to create matrices \(A\), \(B\) and \(R\)
that represent the payoff matrices of the game and the routing matrix
respectively.
For more information on the matrices of the game, refer to
Section~\ref{sec:queueing_systems_and_normal_form_games}.
The code snippet also uses the \texttt{nashpy} library~\cite{nashpy} to
define the game object.

\begin{lstlisting}[
    style=pystyle,
    caption={Python code that defines the game instance.},
    label={lst:abg_tutorial_game_instance},
]
>>> import ambulance_game as abg
>>> import numpy as np
>>> import nashpy as nash
>>>
>>> A, B, R = abg.game.get_payoff_matrices(
...     lambda_2=lambda_2,
...     target=target,
...     alpha=alpha,
...     p_hat=p_hat,
...     lambda_1_1=lambda_1_1,
...     lambda_1_2=lambda_1_2,
...     mu_1=mu_1,
...     mu_2=mu_2,
...     num_of_servers_1=num_of_servers_1,
...     num_of_servers_2=num_of_servers_2,
...     system_capacity_1=system_capacity_1,
...     system_capacity_2=system_capacity_2,
...     buffer_capacity_1=buffer_capacity_1,
...     buffer_capacity_2=buffer_capacity_2,
... )
>>> game = nash.Game(A, B)

\end{lstlisting}

Thus, a Nash equilibrium of the game can be found using the
\texttt{lemke\_howson} function of the \texttt{nashpy} library.
The Python code shown in Listing~\ref{lst:abg_tutorial_nash_equilibrium}
gets a Nash equilibrium of the game instance.

\begin{lstlisting}[
    style=pystyle,
    caption={Python code that finds a Nash equilibrium of the game instance.},
    label={lst:abg_tutorial_nash_equilibrium},
]
>>> strat_1, strat_2 = game.lemke_howson(initial_dropped_label=0)
>>> strat_1
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 1.])
>>> strat_2
array([0., 0., 0., 0., 0., 1., 0., 0., 0., 0.])

\end{lstlisting}

This corresponds to player \(1\) playing a strategy of
\(\sigma^A = (0, 0, 0, 0, 0, 0, 0, 0, 0, 1)\) and player \(2\) playing a
strategy of \(\sigma^B = (0, 0, 0, 0, 0, 1, 0, 0, 0, 0)\).
This in turn corresponds to player \(1\) choosing a threshold of \(T^A = 10\)
and player \(2\) choosing a threshold of \(T^B = 6\).

Apart from the Nash equilibrium, a learning algorithm can also be used to get
an evolutionary stable strategy (ESS) of the game.
In the code snippet shown in Listing~\ref{lst:abg_tutorial_ard}, the results
of the asymmetric replicator dynamics algorithm run are shown.
The code snippet also uses the \texttt{matplotlib} library to plot the
results of the algorithm.


\definecolor{invisiblecomments}{RGB}{253, 246, 220}
\begin{lstlisting}[
    style=pystyle,
    caption={Python code that runs the asymmetric replicator dynamics algorithm.},
    label={lst:abg_tutorial_ard},
    commentstyle=\color{invisiblecomments},
    showstringspaces=false,
]
>>> import matplotlib.pyplot as plt
>>> xs,ys = game.asymmetric_replicator_dynamics(
...     timepoints=np.linspace(0, 10000, 1000)
... )
>>>
>>> plt.plot(xs[0:30]) # doctest: +SKIP
>>> plt.title("Asymmetric replicator dynamics for player 1") # doctest: +SKIP
>>> plt.xlabel("Timepoints") # doctest: +SKIP
>>> plt.ylabel("Probability") # doctest: +SKIP
>>>
>>> plt.plot(ys) # doctest: +SKIP
>>> plt.title("Asymmetric replicator dynamics for player 2") # doctest: +SKIP
>>> plt.xlabel("Timepoints") # doctest: +SKIP
>>> plt.ylabel("Probability") # doctest: +SKIP
    
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.49\textwidth]{chapters/00_appendix/01_ambulance_game_library/Bin/ard_p1.png}
    \includegraphics[width=0.49\textwidth]{chapters/00_appendix/01_ambulance_game_library/Bin/ard_p2.png}
\end{figure}


From the results of both the Lemke-Howson algorithm and the asymmetric
replicator dynamics algorithm, the same pair of strategies is found.
That is player \(1\) choosing a threshold of \(T^A = 10\) and player \(2\)
choosing a threshold of \(T^B = 6\).
The equivalent strategy of the third player; the ambulance service, can be
found from the routing matrix \(R\) in position \(R_{10, 6}\).


\begin{lstlisting}[
    style=pystyle,
    caption={Python code for the strategy of the third player.},
    label={lst:abg_tutorial_routing_strategy},
]
>>> threshold_1, threshold_2 = 10, 6
>>> prop_A = R[threshold_1 - 1, threshold_2 - 1]
>>> prop_B = 1 - prop_A
>>> np.round(prop_A, 2), np.round(prop_B, 2)
(0.95, 0.05)

\end{lstlisting}

In response to the thresholds chosen by the first two players, the ambulance
service chooses to send \(95\%\) of the ambulances to the first hospital and
\(5\%\) of the ambulances to the second hospital.
Having this percentage of ambulances sent to each hospital, the overall waiting
time of patients at each hospital can be calculated.
The Python code shown in Listing~\ref{lst:abg_tutorial_waiting_time} calculates
the waiting time of patients at each hospital.

\begin{lstlisting}[
    style=pystyle,
    caption={Python code for the waiting time of patients at each hospital.},
    label={lst:abg_tutorial_waiting_time},
]
>>> mean_wait_1 = abg.markov.get_mean_waiting_time_using_markov_state_probabilities(
...     lambda_2=lambda_2 * prop_A,
...     lambda_1=lambda_1_1,
...     mu=mu_1,
...     num_of_servers=num_of_servers_1,
...     threshold=threshold_1,
...     system_capacity=system_capacity_1,
...     buffer_capacity=buffer_capacity_1,
... )
>>> mean_wait_2 = abg.markov.get_mean_waiting_time_using_markov_state_probabilities(
...     lambda_2=lambda_2 * (1 - prop_A),
...     lambda_1=lambda_1_2,
...     mu=mu_2,
...     num_of_servers=num_of_servers_2,
...     threshold=threshold_2,
...     system_capacity=system_capacity_2,
...     buffer_capacity=buffer_capacity_2,
... )
>>> np.round(mean_wait_1, 3)
1.257
>>> np.round(mean_wait_2, 3)
0.632

\end{lstlisting}

The results of the calculations show that the average waiting time of patients
at the first hospital is \(1.257\) time units and the average waiting time of
patients at the second hospital is \(0.632\) time units.
Going back to the parameters that relate to the policy imposed on the hospitals,
\texttt{target = 2} and \texttt{p\_hat = 0.7}.
As stated earlier, that corresponds to both hospitals serving \(70\%\) of the
patients within \(2\) time units.
The mean total time of patients is calculated by adding the average waiting
time and the average service time of patients.

\begin{lstlisting}[
    style=pystyle,
    caption={Python code for the mean total time of patients at each hospital.},
    label={lst:abg_tutorial_mean_total_time},
]
>>> np.round(mean_wait_1 + (1 / mu_1), 3)
1.591
>>> np.round(mean_wait_2 + (1 / mu_2), 3)
1.632
    
\end{lstlisting}

The first mean time in hospital \(1\) for patients is \(1.591\) time units and
the mean time in hospital \(2\) for patients is \(1.632\) time units.



\section{How-to guides}\label{sec:ambulance_game_how_to}

\subsection{Discrete Event Simulation}

\subsection{Markov Chains}

\subsection{Object Oriented Implementation} % Should this be here?

\subsection{Game Theoretic Model}





\section{Reference}\label{sec:ambulance_game_reference}

% - Structure of the library
% - List of all functions in the library
% - List of all classes in the library
% - Maybe in the form of a doctree where modules are the top level


\section{Explanation}\label{sec:ambulance_game_explanation}

% - graphical.py?
% - Nashpy and ciw
% - In-depth explanation of the functionality of some code
%     - get_transition_matrix VS get_transition_matrix_by_iterating_through_all_entries
%     - is_steady_state
%     - etc